Prep:
- Don't forget to print more-animal-tree.scm
  and probscheme-dist.scm in small type
- Write some arguments
  - horse, rhino -> seal is poor
  - chimp, cow, mouse -> elephant is better
  - also dolphin, gorilla -> all
- Draw the tree and the evolution formula on the board
  - Mark branch lengths

Feel free to ask questions

This is about how I want to write my probability models
- I want probability embedded in a full programming
  language
- I'll use Scheme becuase it's good for thinking about
  computing

OPTIONAL Slide scheme.scm
- walk through the forms: Polish notation, define, let,
  lambda, car, quote, quasiquote
- mention REPL, data is code?

I Exemplify with a model from Kemp and Tenenbaum 2003
- Cognitive Science paper, models how humans think
- Argument strength task
  - examples on the board
  - Osheron et al collected this data set
- Generative Bayesian model assumes taxonomic tree
  - drawn on the board
- Concepts are generated by a mutation process, can
  turn on at any branch in the tree, poisson process
  as a function of branch length
- How to code this well? clearly?

Slide tree.scm
- A node has a lead-in branch length
- It might be a terminal node
- If it is, it has a symbol
- Else it has a left and a right subtree

Slide mutation-process.scm
- concept is a set of animals with the feature
- walk through recursive definition
- discrete-select is magical, will return to it
  - returns one of the values given, and remembers the 
    probabilities

Slide model.scm
- observe! is magical
  - Frobs the probabilities to make sure that branches 
    that do not satisfy it have probability zero
- with-probabilistic-choices is magical, too


So, how could we implement this?
- Can do rejection sampling
  - discrete-select just uses a random number generator
  - observe! throws observation-violated-exception
  - with-probabilistic-choices catches exceptions and 
    accumulates results
- Better, this implementation does a systematic search
  over all possible choices (draw computation tree)
  - with-probabilistic-choices runs the thunk, 
  - discrete-select returns a choice and stores the 
    probability in some global state
  - observe! modifies the 'running likelihood' of the
    global state
  - with-probabilistic-choices gets a value, stores
    it and its probability, and backtracks to another
    choice, for another value
  - Nice thing about Scheme, you can actually *do* that
    - discrete-select can capture the continuation to
      which it is expected to return, as well as its 
      remaining options, and the backtracker can invoke it

If people want code:
- select-observe
- with-probabilistic-choices
- OPTIONAL choice-try
- OPTIONAL continuations
  - implicit continuations always there, someone always 
    waiting for your value

If people want more talk:
- It should be possible to make the backtracking
  dependency-directed
- "probability distributions" can be lazy about both
  their objects and the precision of their probabilities
  - can do decision theory like this, where you only
    need enough precision to prove which decision is best

For completeness:
- boring-mundanity-1.scm
  - a probability distribution is just an association list
    of objects to probabilities
- boring-magic-1.scm
- boring-magic-2.scm
